'''
1. Создать класс TrafficLight (светофор) и определить у него один атрибут color (цвет) и метод running (запуск).
	Атрибут реализовать как приватный. В рамках метода реализовать переключение светофора в режимы: красный, желтый, зеленый.
	Продолжительность первого состояния (красный) составляет 7 секунд, второго (желтый) — 2 секунды, третьего (зеленый) — на ваше усмотрение.
	Переключение между режимами должно осуществляться только в указанном порядке (красный, желтый, зеленый).
	Проверить работу примера, создав экземпляр и вызвав описанный метод.
    Задачу можно усложнить, реализовав проверку порядка режимов, и при его нарушении выводить соответствующее сообщение и завершать скрипт.
'''
print("\nУрок 6 задание 1\n")

import time
from itertools import cycle
import threading  # Будем использовать многопоточность

class TrafficLight(threading.Thread):  # наследуем наш класс от класса threading.Thread

    __color = 'off'
    number = 0       # номер светофора

    def __init__(self, number):
        threading.Thread.__init__(self)        # инициализируем метод init для threading.Thread
        self.number = number                   # номер светофора
        print(f"Светофор {self.number} установлен")

    def run(self): # переопределяем метод run для threading.Thread, и заодно добавим сюда функционал запуска светофора
        alg = [[7,'Red'], [2,'Yellow'], [5,'Green'], [2,'Yellow']]
        for item in cycle(alg):                # перебираем список раб. режимов в бесконечном цикле
            self.cycle_exit = False            # метка выхода из cycle() - фактически остановка светофора
            self.__color = item[1]             # включаем нужный свет
            print(f"Светофор {self.number} - {self.__color}")
            for _ in range(0, item[0]):        # каждую секунду пока горит выставленный свет ...
                if self.__color == 'off':      # ...проверяем метку выключения светофора, и если её выставил внешний процесс
                    self.cycle_exit = True     # ставим метку завершения цикла
                    break
                else:
                    time.sleep(1)              # если нет метки то продолжаем
            if self.cycle_exit == True:
                print(f"Светофор {self.number} выключен")
                break                          # и выходим из цикла, т.е. останавливаем светофор

    def stop(self): # метод для выключения светофора
        print(f"Выключаем светофор {self.number}")
        self.__color = 'off'

    def getcolor(self): # метод для опеределения света светофора
        return self.__color

class Timer(threading.Thread):  # Заготовка для синхронизатора потоков - тут фактически не используется, просто тикает по 1с
    def __init__(self):
        threading.Thread.__init__(self)
    def run(self):
        for _ in range(0,120): # таймаут на выключение программы (если надо)
            print("-")
            time.sleep(1)
        print("Завершаем программу")
        s1.stop()
        s2.stop()
        exit()

#-------------------------------------------------------------------
print('Запускаем таймер')
t = Timer()
t.start()

# У нас будет два светофора: 1й эталонный и 2й контролируемый
time.sleep(2)
print('Запускаем 1й светофор')
s1 = TrafficLight(1)
s1.start() # метод start() в классе Threding запускает наш метод run()

# специально вводим задержку для их рассинхронизации
time.sleep(10)
print('Запускаем 2й светофор')
s2 = TrafficLight(2)
s2.start()

# видим что светофоры сильно рассинхронизированы

time.sleep(20)
''' вводим задержку для демонстрации процедуры синхронизации светофоров - её планировалось запускать в цикле в 
специально для этого сделанный класс Timer(), но для наглядности работы программы мы её вынесем сюда'''

if s2.getcolor() != s1.getcolor(): # если определена рассинхронизация
    print('Определена рассинхронизация, останавливаем 2й светофор')
    s2.stop()
    while s1.getcolor() != 'Red': # Ждём красный у 1го светофора проверяя его каждую секунду
        time.sleep(1)
    else:
        print("Красный!", s1.getcolor())
        s2 = TrafficLight(2)
        s2.start()

''' Фактическая остановка светофора происходит только на следующем такте частоты опроса 1с, так что синхронизация 
    будет не идеальной - не менее одного такта. Но её можно легко улучшить (при необходимости) уменьшая интервал опроса 
'''


#s1.join()
#s2.join()



